# 트랜잭션

> **트랜잭션**
> 

데이터베이스의 상태를 바꾸는 하나의 작업 단위이다. 트랜잭션은 여러개의 쿼리(명령 및 연산)으로 구성되어있다.

> **트랜잭션이 필요한 이유**
> 

![Untitled](/%5Bokky%5D%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/Untitled.png)

상황 : A가 B에게 돈을 이체하는 상황이다. A의 계좌에서 출금, B의 계좌에 입금이 하나의 작업 단위가 아닌 각각 이루어지는 상황이라고 가정해보자.

1. A는 B에게 5만원을 계좌 이체 요청을 한다.

2. 은행 시스템은 A의 계좌에서 5만원을 출금을 진행한다.

3. 은행은 B의 계좌에 5만원 입금처리를 한다.

각각의 프로세스가 전부 성공적으로 실행된다면 이체에 성공하게된다. 그러나 1,2번 프로세스는 성공하지만 3번

과정을 실패하게 된다면 A의 계좌에서 돈만 빠져나가는 상황이 발생하게 된다. 이런 데이터의 일관성을 유지하지 못하는 상황을 방지하기 위해 트랜잭션이 필요하다.

`이체`라는 과정을 하나의 작업단위로 설정하고, 이체라는 작업은 A계좌 출금, B계좌 입금 명령어로 구성을 하면 데이터의 일관성을 유지시킬 수 있다.

> **트랜잭션 특징 : ACID**
> 

1. 원자성(Automicity) : 트랜잭션은 일부 연산만 실행되서는 안된다. 트랜잭션 결과는 성공하거나 실패하여야 한다.

2. 일관성(Consistency) : 트랜잭션이 성공적으로 완료되면 데이터베이스는 일관된 상태를 유지해야 한다.

3. 독립성(Isolation) : 두개 이상의 트랜잭션이 실행되는 경우 하나의 트랜잭션이 다른 트랜잭션의 연산에 참여할 수 없다.

4. 지속성(Durability) : 성공적으로 실행된 트랜잭션은 시스템에 장애가 발생해도 영원히 반영 완료가 되어야 한다.

> **트랜잭션의 고립성**
> 

대부분의 경우 멀티 코어 환경을 제공하기 때문에 여러개의 트랜잭션은 동시에 실행될 수 있다. 자원은 한정되어 있어 여러 트랜잭션이 해당 데이터를 사용하게 되면 데이터 일관성에 영향을 줄 수 있다. 그렇기 때문에 데이터베이스의 일관성을 지키기 위해서 트랜잭션의 고립에 대한 관리가 필요하다.

> **트랜잭션 격리 수준**
> 

트랜잭션의 고립된 정도를 나타내는 것이다. 트랜잭션이 다른 트랜잭션에 의해 변경된 데이터를 읽을 수 있을지를 결정한다. 트랜잭션 격리 수준의 종류는 다음과 같다. 레벨이 높아질수록 트랜잭션 간 고립도가 높고 성능이 떨어진다.

```
1. 트랜잭션 레벨 0 : READ UNCOMMITTED
2. 트랜잭션 레벨 1 : READ COMMITTED
3. 트랜잭션 레벨 2 : REPEATABLE READ
4. 트랜잭션 레벨 3 : SERIALIZABLE
```

> **데이터베이스 Lock**
> 

트랜잭션 격리 수준을 설명하기 전 데이터베이스의 락에 대해서 설명하려고 한다. Lock 기능은 데이터의 일관성과 무결성(데이터를 언제든지 사용할 수 있어야 하는 특징)을 보장하기 위한 기능이다.

> **공유 락(Shared Lock)**
> 

READ 명령에 주어지는 락으로 READ LOCK이라고 한다. 여러 사용자가 데이터를 동시에 READ해도 데이터의 일관성에 영향을 주지 않기 때문에 공유 락 끼리는 동시에 읽기가 가능하다.

> **배타 락(Exclusive Lock)**
> 

WRITE 명령에 주어지는 락으로 WRITE LOCK이라고 한다. WRITE 명령은 데이터의 변경을 한다. 배타 락이 해제되기 전까지는 다른 연산들은 데이터를 변경할 수 없다. 트랜잭션의 독립성은 배타 락에 의해 지켜진다.

> **레벨 0 : READ UNCOMMITTED**
> 

![Untitled](/%5Bokky%5D%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/Untitled%201.png)

트랜잭션에서 변경된 데이터가 커밋과 롤백에 관계 없이 다른 트랜잭션에서 데이터를 읽을 수 있는 상태다.

트랜잭션이 완료되지 않았음에도 불구하고 다른 트랜잭션에서 볼 수 있는 `DIRTY READ` 가 발생한다.

> **레벨 1 : READ COMMITTED**
> 

![Untitled](/%5Bokky%5D%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/Untitled%202.png)

관계형 데이터베이스에서 기본적으로 사용되는 격리 수준이다. 실제 테이블에 저장된 데이터를 가져오는 것이 아닌 `UNDO 영역`에 백업된 레코드에서 데이터를 가져온다.

- UNDO 영역 : UPDATE/DELETE 문으로 데이터를 변경했을 때 변경되기 전의 데이터를 보관하는 영역이다.

위의 예제에서 문제점은 하나의 트랜잭션에서 동일한 쿼리를 실행했을 때 항상 같은 결과를 가져와야한다. 그러나 첫번째 쿼리문을 실행했을 때는 KAKAO\_MUZI 값을 가져오고 두번째 쿼리문을 실행했을 때 KAKAO_FRIEND를 가져오기 때문에 데이터베이스의 일관성을 어기게 된다.

> **레벨 2 : REPEATABLE READ**
> 

![Untitled](/%5Bokky%5D%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/Untitled%203.png)

한번 조회한 데이터를 다시 조회했을 때 변경된 값으로 조회되는 데이터베이스 일관성을 위반하는 문제를 해결하기 위한 레벨이다. 트랜잭션 내에서 한번 조회한 데이터를 반복해서 조회했을 때 같은 데이터를 조회할 수 있게 한다.

트랜잭션 내에서는 동일한 결과를 나오도록 보장한다. REPEATABLE READ에서는 UNDO 영역에 백업된 레코드의 여러가지 버전 중 자신의 트랜잭션 이전 버전의 레코드만을 참조한다. 그렇기 때문에 일관성 있는 데이터를 조회할 수 있다.

> **레벨 3 : SERIALIZABLE**
> 

트랜잭션이 특정 테이블을 읽는 경우 INSERT/UPDATE/DELETE 를 제한한다. SELECT 의 경우 공유 락 권한을 얻어야 한다.

> **정리**
> 

![Untitled](/%5Bokky%5D%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/Untitled%204.png)
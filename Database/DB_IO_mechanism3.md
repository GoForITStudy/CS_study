# 블록 단위 I/O
- 예를 들어, 클라우드에 위치한 문서는 파일 단위로 저장하고, 파일 단위로 읽는다.

## 블록
- 데이터베이스에서 데이터를 읽고 쓰는 단위
- 특정 레코드 하나를 읽고 싶어도 해당 블록을 통째로 읽는다.
    - 예를 들어 오라클에서는 8KB 크기의 블록을 사용하므로 1Byte를 읽기 위해 8KB를 읽는 셈이다.
- 테이블 뿐만 아니라, **인덱스** 도 블록 단위로 데이터를 읽고 쓴다.

#### 블록 단위
- 오라클은 기본적으로 8KB 크기의 블록을 사용하며, 2, 4, 16KB 블록을 사용할 수도 있다. 
    - OS 플랫폼에 따라 32KB 블록을 지원하기도 한다.
- MS SQL Server는 8KB 단일 사이즈 블록(=페이지)만 지원한다.
```sql
# 오라클에서 블록 사이즈를 확인하는 방법
# 1.
show parameter block_size

# 2. V$PARAMETER 뷰를 직접 조회
select value from v$parameter where name='db_block_size';
```

## 시퀀셜 액세스 vs. 랜덤 액세스
- 테이블 또는 인덱스 블록을 액세스하는 방식 2가지

### 시퀀셜Sequential 액세스 
- 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식
#### 인덱스 리프 블록
- 앞 뒤를 가리키는 주소값을 통해 논리적으로 서로 연결되어 있으며, 이 주소 값에 따라 앞 또는 뒤로 순차적으로 스캔하는 방식이 시퀀셜 액세스다.
#### 테이블 블록
- 테이블 블록 간에는 서로 논리적인 연결고리가 없다.
- 오라클의 경우에는 세그먼트에 할당된 익스텐트 목록을 **세그먼트 헤더**에 맵으로 관리한다.
    - 익스텐트 맵은 각 익스텐트의 첫번째 블록 주소 값을 갖는다.
- **Full Table Scan**
    - 읽어야 할 익스텐트 목록을 익스텐트 맵에서 얻고, 각 익스텐트의 첫 번째 블록 뒤에 연속해서 저장된 블록을 순서대로 읽는 것
### 랜덤Random 액세스
- 논리적, 물리적 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근(touch)하는 방식이다.

## 논리적 I/O vs. 물리적 I/O
### DB 버퍼 캐시
- 디스크 I/O가 SQL 성능을 결정한다.
- SQL을 수행하는 과정에 계속해서 데이터 블록을 읽는데, 자주 읽는 블록을 매번 디스크에서 읽는 것은 매우 비효율적이다.
    - 모든 DBMS에 **데이터 캐싱 메커니즘이 필수**인 이유이다.
- **DB 버퍼캐시**는 데이터를 캐싱하는 SGA의 가장 중요한 구성요소 중 하나
    - 디스크에서 읽은 데이터 블록을 캐싱해 같은 블록에 대한 반복적인 I/O Call을 줄이는데 목적이 있다.
- 서버 프로세스와 데이터 파일 사이에 버퍼 캐시가 존재
    - 데이터 블록을 읽을 때 항상 버퍼캐시부터 탐색한다.
- 버퍼 캐시는 공유 메모리 영역이므로 같은 블록을 읽는 다른 프로세스도 득을 본다.
```sql
# 오라클 SQL*Plus에서 버퍼 캐시 사이즈를 확인하기
show sga

# 혹은 v$SGA 뷰를 통해서 확인한다.
```
#### <-> 라이브러리 캐시
    - 공유 메모리 SGA 구성요소 중 하나
    - SQL과 실행계획, DB 저장형 함수/프로시저 등을 캐싱하는 **코드 캐시**

### 논리적 블록 I/O
- SQL을 처리하는 과정에 발생한 총 블록 I/O
    - 메모리 I/O가 곧 논리적 I/O라고 생각할 수 있다.
    - Direct Path Read 방식으로 읽는 경우를 제외하면, 모든 블록은 메모리 상의 DB 버퍼 캐시를 경유해서 읽는다.
        - 메모리를 경유하지 않는 Direct Path I/O를 고려한다면, 논리적 I/O는 메모리 I/O와 Direct Path I/O를 더한 개념이다.
        - 디스크 소트 과정에서 소트 Runs로부터 블록을 읽거나 병렬 쿼리로 Full Scan을 수행할 때, Direct Path Read 방식을 사용한다.
    - 논리적 I/O 횟수는 일반적으로 DB 버퍼 캐시에서 블록을 읽은 횟수와 일치한다.
    - 논리적 I/O와 메모리 I/O의 개념은 다르나, 결과적으로 수치는 같다.
- SQL을 수행하면서 읽은 총 블록 I/O가 논리적 I/O 다.
    - 테이블에 데이터를 입력하거나 삭제하지 않은 상황에 조건절에 같은 변수 값을 입력하면, 여러 번 실행하더라도 매번 읽는 블록 수는 같다.
### 물리적 블록 I/O
- 디스크에서 발생한 총 블록 I/O
    - SQL을 처리하는 중 버퍼 캐시에서 찾지 못한 블록을 가져오기 위해 디스크에 액세스한다.
    - 논리적 블록 I/O 중 일부를 물리적으로 I/O 한다.
- 데이터의 입력이나 삭제가 없어도 물리적 I/O는 SQL을 실행할 때 마다 다르다.
    - 연속해서 실행하는 경우, 해당 테이블 블록의 DB 버퍼 캐시 점유율이 더 높아지기 때문이다.
    - 한참 후에 다시 실행하면(다른 테이블 블록의 점유율이 높아지는 경우), 반대로 물리적 I/O가 늘어난다.

#### 성능 차이
- 메모리 I/O는 전기적 신호인데 반해, 디스크 I/O는 액세스 암Arm을 통해 물리적 작용이 일어나므로 보통 10,000 배 쯤 느리다. 
    - 디스크 경합이 심한 경우에 더 느리다.

### 버퍼 캐시 히트율 BCHR
- 버퍼캐시 효율을 측정하는 데 전통적으로 가장 많이 사용해 온 지표
```
BCHR = (캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수) * 100
    = ((논리적 I/O - 물리적 I/O) / 논리적 I/O) * 100
    = (1-(물리적 I/O) / (논리적 I/O)) * 100
```
- 읽은 전체 블록 중에 물리적 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾은 비율을 말한다.
- 온라인 트랜잭션을 주로 처리하는 어플리케이션이라면 시스템 레벨에서 평균 99% 히트율을 달성해야 한다.
    - 핵심 트랜잭션이 시스템 전체 부하의 대부분을 차지하므로 열심히 튜닝하면 99%는 결코 달성하기 어려운 수치가 아니다.
#### BCHR 에서 보는 중요한 성능 원리
- 물리적 I/O가 성능을 결정하지만 실제 성능을 향상하려면 물리적 I/O가 아닌 논리적 I/O를 줄여야 한다는 사실이다.
```
물리적 I/O = 논리적 I/O * (100% - BCHR)
```
- BCHR은 시스템 상황(외부 요소, 즉 통제 불가능한 외생 변수)에 따라 달라진다.
- 논리적 I/O는 일정하므로, 물리적 I/O는 BCHR에 의해 결정된다.
    - 즉, 외부 요소, 즉 통제 불가능한 외생 변수
        - 메모리를 증설해서 DB 버퍼캐시 크기를 늘리는 방법 외에 줄일 수 있는 방법은 없다.
    - 논리적 I/O는 SQL 튜닝을 통해 줄일 수 있는 통제 가능한 내생변수
- 즉, SQL 성능을 높이기 위해 할 수 있는 일은 논리적 I/O를 줄이는 일 뿐이다.
- **논리적 I/O를 줄이기 위해서는 SQL을 튜닝해서 읽는 총 블록 갯수를 줄이면** 된다.
    - 물리적 I/O도 줄고 성능도 향상된다.

#### BCHR 에서 주의해야 할 함정
- BCHR이 SQL 성능을 좌우하지만, BCHR이 높다고 항상 효율적인 SQL을 의미하지 않는다.
- 같은 블록을 비효율적으로 반복해서 읽으면 BCHR이 높아진다. (인덱스와 NL 조인 관련)
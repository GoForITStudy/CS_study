## Design Pattern

- 유사한 문제를 해결하기 위해 설계들을 분류하고 각 문제 유형별로 가장 적합한 설계를 일반화하여 체계적으로 정리해 놓은 것으로 소프트웨어 개발에서 `효율성` 과 `재사용성` 을 높일 수 있다.
- 확장과 수정에 용이하여 설계 이후에도 추가적인 유지 보수에 비용이 적게 들어가는 코드를 말한다.
- `객체지향 개발 위주`로만 사용하고, 객체지향적으로 객체 간 **응집도는 높이고, 결합도는 낮게**하기 위함이다.

## 생성패턴

- 객체를 생성하는 데 사용되는 패턴이다.
- 클래스 정의와 객체 생성 방식을 구조화, 캡슐화한 방법을 제시한다.
- 시스템이 어떤 구체적인 클래스를 사용하는지에 대한 정보를 [캡슐화](https://javacpro.tistory.com/31)한다.
- 객체를 생성하거나 수정되어도 프로그램 구조에 영향을 적게 받도록한다.

### 1) Factory Method

- 객체를 만들어내는 공장을 만드는 패턴이다.
- 서브 클래스가 인스턴스를 결정하도록 한다.
- 객체를 생성하는 코드를 분리하여 클라이언트 코드와 결합도를 낮춘다.
  - 코드 변경 필요 시, 객체 생성 클래스만 수정하면 된다.
- 인터페이스를 바탕으로 유연성과 확장성이 뛰어난 코드 제작이 가능하다.
- 객체의 자료형이 하위 클래스에 의해서 결정된다.
  - 확장에 용이함
  - 상위 클래스에서 그 객체에 대한 정확한 타입을 몰라도 된다.

**장점**

- 객체 생성 하는 코드를 분리하여 클라이언트 코드와 결합도(의존성)를 낮춤.
  - 코드에 변경이 필요할 시, 객체 생성 클래스만 수정하면 된다.
- 인터페이스를 바탕으로 유연성과 확장성이 뛰어난 코드 제작이 가능
- 객체의 자료형이 하위 클래스 의해서 결정됨
  - 확장에 용이함
  - 상위 클래스에서 그 객체에 대한 정확한 타입을 몰라도 된다.

**단점**

- 새로 생성할 객체의 종류가 늘어날 때마다, 클래스가 많아진다.

### 2) Abstract Method

- 기존 팩토리 메소드 방식에서 팩토리의 상위 팩토리를 통해 구체적인 팩도리를 생성한다.

### 3) Builder

- 객체를 생성할 때 복잡한 과정을 분리한다.

- 많은 인수를 가진 객체를 생성할 때 다른 객체의 도움으로 생성하는 패턴이다.

- 데이터의 순서에 상관없이 객체를 만들어 낸다.

  [Builder의 예제 코드](https://dailyheumsi.tistory.com/187)

### 4) Prototype

- `new`를 사용하지 않고 인스턴스를 그대로 복제하여 새로운 객체를 생성한다.
- 생성하는 객체가 동일하고 객체의 값이나 크기가 변하게 될 때 유용하다.

### 5) Singleton

- 한 클래스에 한 객체만 존재하도록 제한하는 패턴이다.

- 유일한 멤버 변수 `Static` 으로 선언하여 다른 클래스의 인스턴스들이 데이터를 공유하게 한다.

- `Private` 으로 접근을 제한한다.

  [Singleton의 예제 코드](https://dailyheumsi.tistory.com/149)

## 구조패턴

- 여러 개의 객체를 모아 구조화시키는 패턴으로 새로운 기능을 제공하게 한다.
- 여러개의 객체에 접근할 수 있는 인터페이스를 제공한다.
- 다른 기능을 가진 객체가 협력에 의해 어떠한 역할을 수행할 때 객체를 조직화시키는 일반적인 방식을 제시한다.

### 1) Adapter

- 이미 만들어져 있는 클래스를 사용하고 싶지만 인터페이스가 원하는 방식과 일치하지 않을 때, 또는 관련성이 없거나 예측하지 못한 클래스들과 협동하는 재사용 가능한 클래스를 생성하기를 원할 때 사용한다.
- [Adapter의 예제 코드](https://dailyheumsi.tistory.com/189)

### 2) Composite

- 여러 개의 클래스가 크게 보면 같은 요소(Component)에 속하지만, 여기에 속한 어떤 클래스(Composite)가 자기 자신 혹은 다른 클래스(Leaf)를 가질 수 있는 구조이다.
- 복합 객체와 단일 객체의 처리 방법이 다르지 않으면 전체와 부분 관계로 정의 가능하다.
- 트리 구조 형태로 Directory-File 구조 형태가 대표적이다.
- Composite의 구조

### 3) Decorator

- 각각의 기능을 담당하는 클래스들과 이 기능을 적용할 클래스를 분리한 뒤, 필요에 따라 동적으로 각 기능을 적용할 수 있는 구조이다.
- 소스를 변경하지 않고 기능을 확장하도록하는 패턴이다.
- [Decorator의 예제 코드](https://dailyheumsi.tistory.com/198?category=855210)

### 4) Proxy

- 구체적인 업무를 담당하고 있는 클래스에 접근하기 전에, 간단한 사전 작업 처리하는 클래스를 두는 구조이다.
- Proxy 구조 패턴의 종류
  - Remote Proxy : 원격으로 접속하는 기능을 대리 사용한다.
  - Virtual : 가상적인 차원을 사용할 때
  - Protection : 보안이 요구되는 객체에 접근을 통제할때
  - Smart Reference : 부가적인 작업을 수행할 때
- Proxy의 구조

### 5) Facade

- 클라이언트와 복잡한 서브 시스템 사이에 파사드가 존재한다.
- 서브 시스템들 사이에 높은 결합도를 갖거나, 서브 시스템들의 구현이 바뀌어 혼잡할 때 사용
- [Facade의 예제 코드](https://kscory.com/dev/design-pattern/facade)

### 6) Flyweight

- 모든 객체를 개별적으로 생성하고 유지하는 대신 공통으로 사용 가능한 부분을 공유하여 메모리를 절약하는 구조 패턴이다.

### 7) Bridge

- 하나의 클래스 계층에 존재하는 `기능 클래스` 와 `구현 클래스` 를 분리하여, 두 개의 클래스를 연결하여 하용하는 것이다.

- [Bridge의 예제 코드](https://readystory.tistory.com/194)

  출처 | https://www.crocus.co.kr/1537

## 행동패턴

- 객체의 구체적인 알고리즘을 정의하는 패턴이다.
- 반복적으로 사용하는 객체들의 상호 작용을 패턴화한 것으로 객체의 행위를 조직화, 관리, 연합하는데 사용되는 패턴이다.

### 1) Chain of Responsibility

- **책임 연쇄 패턴**이라고 하며 하나의 문제가 발생했을 경우, 같은 인터페이스의 다른 객체에게 해당 요청을 전달하며 여러 개의 처리기를 두고 순서대로 처리해 나가는 패턴이다.
- [Chain of Responsibility의 예제 코드](https://dailyheumsi.tistory.com/213?category=855210)

### 2) Command

- 매개 변수를 사용하여 여러 가지 다른 요구사항을 처리할 수 있다.
- **커맨드 자체를 객체화 한다.**
- [Command의 예제 코드](https://dailyheumsi.tistory.com/217?category=855210)

### 3) Interpreter

- 간단한 언어의 문법(Text, SQL 구문 분석, 기호 처리 etc.)을 정의하고 해석하는데 사용되는 패턴이다.

### 4) Mediator

- 여러 객체들이 서로 메시지를 주고받는 상호 작용을 특정 객체 안에 캡슐화 하여, 클래스 간의 모든 통신을 처리하고, 약한 결합으로 코드를 쉽게 유지 관리할 수 있는 중재자 클래스를 제공한다.
- [Mediator의 예제 코드](https://snowdeer.github.io/designpattern/2016/05/11/design-pattern-mediator/)

### 5) Memento

- 객체의 상태를 저장해 두었다가 복원해야 할 경우 사용하는 패턴이다.

### 6) Observer

- 어떤 클래스에 변화가 일어났을 때, 다른 객체에 의존하지 않으면서 다른 클래스에게 데이터 변경을 통보한다.

### 7) State

- 규칙에 따라 객체의 상태를 변화시키면서 객체가 할 수 있는 행위를 바꾸는 패턴이다.
- [State의 예제 코드](https://dailyheumsi.tistory.com/212?category=855210)

### 8) Strategy

- 행동/전략 등 동일계열의 알고리즘별로 캡슐화되어 있는 객체들을 교체할 수 있도록 함으로써 같은 작업을 다른 알고리즘으로 사용할 수 있도록 하는 패턴이다.

**장점**

- 상황에 따라 사용할 알고리즘을 쉽게 바꿀 수 있다.
- 알고리즘 구현부와 사용부가 분리되어 있다.
  - 인터페이스로 사용자는 일관성있게 알고리즘을 가져다 쓸 수 있고,
  - 각 알고리즘들은 동일한 인터페이스를 가지되, 각각 목적에 따라 구현은 다르게할 수 있다.

**단점**

- 다 사용하지 않는 정보들을 모든 알고리즘이 떠안아야 한다.
  - 각 구체적인 알고리즘들마다 필요한 입력 파라미터가 다 다를 수 있다.
  - 하지만 인터페이스로 파라미터가 고정되어 있으므로, 굳이 이 알고리즘에 필요없는 파라미터도 다 받게된다.
- 알고리즘 수 만큼 전체 객체 수가 증가한다.

**활용 상황**

- 내비게이션 SW에서 GPS 신호를 수신하는 경우와 못하는 경우에 따라 차량의 위치를 구하는 다른 알고리즘을 선택하고자 할 때 사용한다.
- 가격 변동이 자주 발생하는 CPU나 메모리와 같은 컴퓨터 부품 등의 소비재의 가격을 캡슐화하여 쉽게 변경 및 추가할 수 있게 한다.
- [Strategy의 예제 코드](https://dailyheumsi.tistory.com/209?category=855210)

### 9) Template Method

- 알고리즘을 메소드로 정의하고 하위 클래스에서 알고리즘 구조의 변경 없이 알고리즘을 재정의한다.
- [Template Method의 예제 코드](https://dailyheumsi.tistory.com/210?category=855210)

**장점**

- 로직과 로직요소를 분리하여, 전체 로직은 동일하되 로직 요소를 각각 다르게할 수 있다.

**단점**

- 추상 클래스와 구현 클래스가 강하게 연결되어 있다.
  - 상속 때문에 하향적으로 강해지는 한편, 상위 클래스의 메쏘드를 사용하므로 상향적으로도 강해진다.
- 로직 요소(추상 메쏘드) 가 많아지면 클래스 자체가 복잡해질 수 있다.

### 10) Iterator

- 반복이 필요한 자료 구조를 모두 동일한 인터페이스를 통해 접근 할 수 있도록 하는 패턴이다.
- 집합 객체 요소들에 대해 순서대로 접근하는 방법을 제공한다.
  - 배열, 배열 리스트, 해시 테이블과 같은 객체를 처리하는 데 사용되는 패턴이다.

### 11) Visitor

- 기존 객체의 구조를 수정하지 않고 새로운 기능을 추가할 수 있는 패턴이다.
- 멤버 변수와 멤버 메소드를 다른 클래스로 분리하여 서로 간 호출하게 한다.
- [Visitor의 예제 코드](https://dailyheumsi.tistory.com/216?category=855210)
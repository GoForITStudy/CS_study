# [Java] 멀티 스레드

## 🦥 1. 멀티 스레드 개념

### 1.1 프로세스와 스레드

- `프로세스` : 실행 중인 프로그램으로 메모리를 할당받은 상태
- `스레드` : 프로세스 내에서 스택만 따로 할당받고 Code, Data, Heap 영역을 공유

### 1.2 멀티 태스킹과 멀티 스레드

- `멀티 태스킹` : 두가지 이상의 작업을 동시에 처리하는 것으로 병렬로 프로세스를 실행
    - 노션 애플리케이션, 크롬 브라우저를 동시에 켜놓고 작업
    - 크롬 브라우저를 2개 이상 실행 시켜서 작업
- `멀티 스레드` :  애플리케이션 내부에서의 멀티 태스킹
    - 카카오톡과 같이 채팅과 파일 전송을 동시에 하는 것

### 1.3 멀티 스레드의 장단점

> 장점
> 
- 프로세스 간의 통신은 공유 메모리, 커널 메세지 등을 이용해야하지만 스레드간 통신은 Heap 을 통해 데이터를 주고받을 수 있음
- CPU 처리량이 향상되고 자원 소모가 줄어 프로그램 응답 시간을 단축

> 단점
> 
- Data, Heap 영역을 공유하기 때문에 자원에 대한 동시 접근에 대해서도 관리해야 함
- 동기화 작업이 필수적임

### 1.4 싱글 스레드와 멀티 스레드

![Untitled](%5BJava%5D%20%E1%84%86%E1%85%A5%E1%86%AF%E1%84%90%E1%85%B5%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20a4e26e9dae4d410c99225727fb6a3d7e/Untitled.png)

싱글 스레드의 경우 메인 스레드가 종료되면 프로세스도 종료. 멀티 스레드 애플리케이션은 실행 중인 스레드가 하나라도 있다면 프로세스는 종료되지 않음.

## 🦥 2. Java 스레드 생성 및 실행

### 2.1 Thread 클래스를 이용한 스레드 생성

- Thread 클래스로 스레드 생성
    
    ```java
    Thread thread = new Thread(Runnable target);
    ```
    
    Thread 클래스로부터 작업 스레드를 직접 생성하려면 `Ruunable 타입의 매개변수를 갖는 생성자`를 호출하여 객체 생성을 해야 함
    
    ```java
    public class TaskOne implements Ruunable {
    		public void run() {
    				스레드가 실행할 코드!
    		}
    }
    ```
    
    Ruunable 은 스레드가 아닌 작업 내용을 가지고 있는 객체. 실제 스레드는 Thread 생성자의 파라미터에 Ruunable 을 구현한 클래스를 매개변수를 넣어 스레드 객체를 생성해야 스레드가 생성된다.
    
- Thread 실행
    
    ```java
    thread.start();
    ```
    
    Thread 객체의 `start` 메서드를 실행하면 매개변수 값으로 받은 작업의 run 메서드를 실행하며 작업을 처리
    

### 2.2 Thread 하위 클래스로부터 생성

- Thread 를 상속받아 생성
    
    ```java
    public class TaskTwo extends Thread {
    		@Override
    		public void run() {
    				스레드가 실행할 코드!
    		}
    }
    
    Thread thread = new TaskTwo();
    ```
    
    작업 스레드가 실행할 작업을 Runnable 로 만들지 않고 Thread 하위 클래스로 작업 스레드를 정의와 작업 내용 포함을 동시에 할 수 있음
    

## 🦥  3. 스레드 우선순위

- `동시성` : CPU 가 하나인 경우 동시에 실행되는 것 처럼 보이지만 하나의 스레드가 실행이 끝나야 그 다음 스레드가 실행
- `병렬성` : 멀티 코어인 경우 스레드를 동시에 실행할 수 있음

싱글 코어라 스레드가 번갈아가며 실행되어야 할 경우, 멀티 코어의 개수보다 스레드의 개수가 많은 경우 우선순위를 정해야함.

### 3.1 JVM을 이용한 우선순위 할당

- 시간 할당량을 정해서 하나의 스레드를 정해진 시간만큼 실행하고 다른 스레드를 실행하는 방식
- JVM에 의해 우선순위가 정해지기 때문에 코드로 제어할 수 없음

### 3.2 코드로 우선순위 할당

- 우선순위가 높은 스레드가 실행 상태를 더 많이 가지도록 스케줄링하여 스레드를 실행
- 스레드 객체에 우선순위 번호를 부여할 수 있기 때문에 코드로 제어 가능
- 1(우선순위 최소값)~10(우선순위 최대값) 까지의 값 혹은 Thread 클래스 상수를 사용

```java
thread.setPriority();
```

## 🦥 4. 동기화 메서드와 동기화 블록

- 멀티 스레드 프로그램은 스레드들이 객체를 공유해서 실행되기 때문에 동기화가 필요
- 스레드가 사용 중인 객체를 다른 스레드가 변경할 수 없도록 하기 위해 `스레드 작업이 끝날 때 까지 객체에 잠금`을 걸어야함

### 4.1 동기화 메서드 및 동기화 블록

- `임계영역` : 멀티 스레드 프로그램에서 하나의 스레드만 실행할 수 있는 코드 영역
- 동기화 메서드와 동기화 블록은 임계 영역
- 스레드가 객체 내부의 동기화 메서드, 동기화 블록에 들어가게 되면 객체에 잠금을 걸고 다른 스레드가 임계 영역 코드를 실행할 수 없도록 함
- `synchronized` 를 사용하여 동기화 메서드 선언 가능

![Untitled](%5BJava%5D%20%E1%84%86%E1%85%A5%E1%86%AF%E1%84%90%E1%85%B5%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20a4e26e9dae4d410c99225727fb6a3d7e/Untitled%201.png)

### 4.2 동기화 메서드 예제

> StringBuffer 와 StringBuilder
> 
- `StringBuffer` : Synchronized 동기화를 지원하여 멀티 스레드 환경에 안전
- `StringBuilder` : 동기화를 지원하지 않아 단일 스레드 환경에서 사용해야 안전

## 🦥 5. 스레드 상태

### 5.1 스레드 상태

![Untitled](%5BJava%5D%20%E1%84%86%E1%85%A5%E1%86%AF%E1%84%90%E1%85%B5%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%20a4e26e9dae4d410c99225727fb6a3d7e/Untitled%202.png)

1. 스레드 객체를 생성하고 `start` 메서드를 호출하면 실행 상태가 아닌 실행 대기 상태
2. 실행 대기 상태의 스레드 중 스레드 스케줄링으로 선택된 스레드가 CPU 를 점유하고 `run` 실행. 이때 스레드는 실행 상태
3. 실행 대기와 실행 상태를 번걸아가며 run 메서드 실행
4. 더 이상 실행할 코드가 없으면 스레드는 종료 상태

### 5.2 스레드 상태 제어 메서드

- 실행중인 스레드의 상태를 변경하는 것을 스레드 상태 제어
- 넷플릭스 예시 : 일시 정지와 종료

[스레드 상태 제어 메서드](https://www.notion.so/886a3dd7a6c3402189ab009ad1ccfa11)